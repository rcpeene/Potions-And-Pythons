
DESIGN FOR POTIONS & PYTHONS


TABLE OF CONTENTS:

SECTION 1 - Reading This Code Project
	Styleguide
	Overview of Files
	Definitions

SECTION 2 - Fundamental Objects
	GameObject
	Game
	Room
	Item
	Status Conditions

SECTION 3 - Creatures & the Player
	Creature
	Player
	Carrying and Riding
	Equipping

SECTION 4 - The World & Portals
	The World
	objQuery() & the object tree
	Portals and Links
	Containers

SECTION 5 - Saving & Loading the Game
	Menu
	JSON Representation, convertToJSON
	buildWorld() and assignRefs()

SECTION 6 - Parsing & Intepreting Input
	Tokenizer and Parser
	Interpreter
	Action functions
	parseGo

SECTION 7 - Weapons, Armor & Combat

SECTION 8 - Effects & Additonal Items

SECTION 9 - Crafting, Brewing & Cooking

SECTION 10 - Creature Behavior & NPCs

SECTION 11 - Dialogue
	Dialogue Trees
	Dialogue Nodes
	Reactions

SECTION 12 - Printing & Output
	Print()
	TeeLogger & transcript.log
	SidePanel



==================== SECTION 1 - READING THIS CODE PROJECT ====================

	STYLEGUIDE

- source files are named with capital letters to distinguish them from python modules

- tabs	are	used	for	indentation,	not	spaces

- the standard maximum line-width is 92 characters for this code, with few exceptions

- functions typically use camelCase for naming, see 3 exceptions below

- Action functions are named with single capitalized words. Action functions are functions 
in Parser.py that are called as a result of Player commands, or methods which are called by
a corresponding Parser.py action function. For instance, the Look() function, which may 
call an examine() method on an item. This is to distinguish these functions from certain
python keywords and built-ins

- Creature stats are named as lowercase abbreviatons, while the functions that return those 
stats are all capitalized such as STR(), MXHP(), and ATCK()

- Classes are named with capitalized first-letters

- typically, instances of objects are either denoted with capital letters, or with words.
For example, an instance of the Item() class may either be I, item, or some other word 
depending on the use case.

-strings are denoted with "", unless it is necessary to use a string that contains " in it,
in which case, the entire function of relevance uses '' to denote strings



	OVERVIEW OF FILES

- src/Data.py contains tuples, sets, and dictionaries that are globally useful in this
project or that would take up unnecessary space in the other files

- src/Core.py is the most important source file for this project. It contains all the 
fundamental objects in the game, such as Game, GameObject, Item, Creature, and Player,
and a number of fundamental functions

- src/Items.py and Creatures.py contain additional objects in the game that require their
own logic.

- src/Effects.py contains functions which interact with the world and inputs that can be 
accessed as spells or for specific object functionality parametrically. For instance, the
Controller object takes an 'effect' as a parameter. Instead of storing all possible effects 
in the Controller class, they can be accessed from Effects.py

- src/Menu.py contains the functions to manage the main menu and to serve as the endpoint
for saving and loading the game with JSON.

- src/Interpreter.py is the main interface of the game. It handles processing user input, 
identifying the objects being interacted with by the user, and evoking their functionality.

- src/PoPy.py is the game endpoint. It runs the main game loop.

- test/Test.py is the module used for testing the game. It reads the .txt files in the 
test folder as though they are user input and attempts to run a game.

- gamedata/transcript.log stores a transcript of the most recent playthrough. 
This can be useful for debugging.

- gamedata/World.json is the base world of the game. It stores the object tree
of each Room in the world. It was intentionally made JSON to be human-readable
and human-editable.

- gamedata/Dialogue.json is all of the game's dialogue trees stored as JSON

- saves/ is where the saved game data is stored. Each save folder should have 
a world.json, a player.json, and a game.txt



==================== SECTION 2 - FUNDAMENTAL OBJECTS ==========================
==================== SECTION 3 - CREATURES & THE PLAYER =======================
==================== SECTION 4 - THE WORLD & PORTALS ==========================
==================== SECTION 5 - SAVING & LOADING THE GAME ====================
==================== SECTION 6 - PARSING & INTERPRETING INPUT =================
==================== SECTION 7 - WEAPONS, ARMOR, & COMBAT =====================
==================== SECTION 8 - EFFECTS & ADDITIONAL ITEMS ===================
==================== SECTION 9 - CRAFTING, BREWING & COOKING ==================
==================== SECTION 10 - CREATURE BEHAVIOR & NPCS ====================
==================== SECTION 11 - DIALOGUE ====================================
==================== SECTION 12 - PRINTING & OUTPUT ===========================








GAMEPLAY MECHANIC GOALS:

-lore/easter eggs are conveyed to the player in engaging but mysterious ways
-players can get a well-formatted display and description of their stats
-enemies and player have a perception system
-save ability and checkpoints, where respawn occurs if players die
-npcs have dynamic communication options which interact with RP
-combat can happen in a dynamic way, which may not always end in a death
-tinkering can be done to create and adapt items magically
-global events can occur which persistently alter something about the world
-rooms are persistent globally
-spells can occur and affect the game in many unique ways
-fun cheat codes? (git, excelsior)



CORE CODE DESIGN:

some file contains base framework;
	player class, room class, item class
okay so some file contains all room objects in the world
another file contains all creatures objects in the world
another file contains all item objects in the world
main will probably contain the parser, player object and all action functions

a txt file contains the save, which includes:
	all player stats
	current room
	all rooms in the world and their contents/settings? <- hard part
	certain global event variables

in main
there are two major objects
	player
	game (containing currentroom, prevroom, and time)

player contains all player attributes and methods
currentroom contains a room object of the room the player is currently in
prevroom represents the last room object that was currentroom
time represents the number of player actions taken since the game's beginning



FRAMEWORK OF THE GAME
every room contains a set of string room names denoting its connected rooms
main() runs a parsing loop, that loops taking valid input
	when parser encounters a valid command, it runs, calls an action function, which may do various things.

	The move() action will check for valid commands, and triage which room to move to, if any possible given the command. This will take the correct room object stored in currentroom's set of room connections, initialize the new room, set previous room to current room and set current room equal to new room, then call current room's "enter" function, which will print the initial room description and take care of some initial things

	Most other valid actions either alter some feature of the room object, some item in the room, something about the player object, or do some of each.

	Additionally, certain commands do external things, like save the game, cancel last action, or print useful info for the player





HOW PARSING INPUT WORKS (EXAMPLE)
```
What will you do?
> I will take my Sword of Legend, from out of the Great Stone.
```

- input processing in tokenize():

First, the input is purified by removing extraneous symbols:
"I will take my Sword of Legend from out of the Great Stone"

Then, the raw input is turned to lowercase:
"i will take my sword of legend from out of the great stone"

Then, the input is split by spaces into a list of words:
["i","will","take","my","sword","of","legend","from","out","of","the","great","stone"]

The nounify() step combines words which appear to be a single meaningful term:
["i","will","take","my","sword of legend","from","out","of","the","great stone"]

Next, articles and determiners (and other extraneous words) are removed:
["take","sword of legend","from","out","great stone"]

- parsing input in parse():

the verb is assumed to be the first term of the processed command:
	verb = "take"
If the command is multiple terms, the preposition is found (if it exists) by comparing each term to a set of known prepositions. In this case:
	prep = "from"
if there are more terms, the direct object is assumed to be the first term after the verb that is not a preposition. In this case:
	dobj = "sword of legend"
if there are still more terms, the indirect object is the first term after the preposition or direct object. In this case:
	iobj = "great stone"

So parse() assigns terms to verb, dobj, iobj, and prep. Often, some or all of these parts may not exist in the user input, in which case they are set to None.

You might notice that, if a direct object is not given, 'dobj' will be set to what is actually the indirect object, and 'iobj' will remain None. Usually, this is acceptable, and the action functions are designed to handle this situation.

The nature of this input parser is such that it cannot accurately parse input with more than these four important parts. It cannot properly interpret arbitrarily complex input.

Once these four parts are determined from parsing, the verb is used to identify the corresponding action function to call with the other three parts as parameters. Like so:

	actionFunc(dobj,iobj,prep)
	actions["take"]("sword of legend","great stone","from")

At which point the action function may ask for more input, do additional interpretation, or execute the action.





ROOM:

room has several attributes:
name - every room must have a unique name
description
size?
allexits: set of adjacent rooms (n, ne, e, se, s, sw, w, nw, u, d, b)
exits: set of directions denoting accessible adjacent rooms
allcontents: set of all items and creatures in the room
contents: set of booleans denoting which items and creatures are 'hidden' or not
additional room booleans and characteristics
types: "covered", "floating", "road"


#note: each object should contain a list of objects it is adjacent to in the room. Any objects adjacent to eachother must share all adjacent objects
#currently in question: should room store a 2d array of items which are passable/impassable.
#alternative answer: objects all participate in an adjacency matrix as discussed above, but they include a distance factor ranging from (adjacent, near, far, distant, on top of, under, within?) and room include a size factor (small, medium, large, vast)

#idea about movement (in or out of combat): movement determines how many steps it takes you to change from adj,near,far,distant or any of those in between. And in that "time" span it takes you to move, other creatures can do things.
#ex. you move from adj to far, which is a constant distance of 50, your movement is 30, so it takes you two steps to move, meanwhile the goblin could attack twice.

room methods:
init
repr
describe exits
describe contents
describe #gonna be elaborate


NOTES WHEN MAKING A ROOM:
- every room must have a unique name which is NOT also a term in any of the game's data sets (except the World dict, which consists entirely of Room names)
- by convention and necessity, room names must be lowercase (since user input is always lowercase and string comparisons are frequently done with room names)
- every room exit must refer to the name of an existing room (otherwise runtime errors will occur)
-pay attention to room exits. Generally, a connection between any two rooms should be two-way. That is, if "glen" has a northern exit to "big tree", "big tree" should have a southern exit to "glen". Exceptions to this recommendation are allowed but should only be used when there's good in-game reason to do so
-every item in the room must be of an existing item class
-every creature in the room must of an existing creature class




ITEM:
An item is any object in the game which can be interacted with which is not a room and which is not a creature. Specifically, an item can exist within a room's contents, within another item's contents, or within a Creature's inventory (including Player's inventory)

The simplest item has attributes; name, description, weight, and durability.
Items of class Weapon() come with a number of additional attributes regarding their statistics as a utility in combat.
Items of class Box() come with a boolean "open" attribute and a list of "contents" of Items they contain.
Items of class Sign() contain a "text" attribute"
Items of class Switch() contain an "effect" attribute, which is a string which is used with the global "effects" dict, mapping these strings to Effect functions. Effect functions affect the World in some way.

NOTES WHEN MAKING AN ITEM:
- Items do not necessarily have to have unique name, but there are parsing limitations when multiple items have the same name. Only give two items the same name if they are identical or negligibly distinct to a user.
- Items names should NOT be a term which also exists in any of the game's data sets (except the Items dict, which consists entirely of Item names). There are cases where code will be unable to reliably parse the ambiguity between an item name and some other important term, like the direction "up", or the word "toward", for instance.
- When adding an item, make sure its class exists in the Objects.py Items dict
- The order of attributes matters! when writing the attributes into the World data file, the attributes must be in the correct order as defined in the __init__ method of the class



PLAYER:

NAME - player-defined name

RACE - what character race you are, each race gets a stat bonus to two stats

DESCRIPTION - player-defined character description

BASE - defined as a dict of 10 pairs

DERIVED - defined as a dict of 24 pairs

LV - level (int)
player level, initially 1, ranges 1-20

XP - experience (int)
player experience points, initially 0, ranges.. to 100,000??

RP - reputation points (int)
reputation you've built for yourself, initially 0, ranges -100 to 100. Having a higher charisma improves your potential to alter your RP

HP - current hit points (int)
initially max, ranges 0 to MXHP

MP - current mana points (int)
initially max, ranges 0 to MXHP

MONEY - defined as a list [cp, sp, gp, pp]
			represented	by	%	&	$	@

INVENTORY - defined as a list [] containing objects of class item, infinite size

GEAR - a dict of many pairs, each one representing a slot in which an item can be equipped. Included player's hands, clothing, and additional items.

STATUS - a set of all status effects currently affecting the player

CHARACTER CREATION:

Gender:
Man +1 STR
Woman +1 CHA
Other + LCK

Age: (affects socialization)
Young +1 STM
Mature +1 INT
Aged +1 WIS
Elderly +1 FTH

Build: (affects base weight)
Lean +1 SPD
Medium +1 SKL
Hefty +1 CON

Hair:
Black
Brown
Red
Blond
White
None


LEVELING:

XP - experience points
amount of experience player has amassed
gained by fighting, killing, socializing, praying, etc.

LV - level
player level, ranging 1 - 20
determined by XP
LV = min1(floor(  5*log10(x/10)  ))

QP - quality points
amount of experience player has with different attributes called qualities.
determined by level and race
the lowest any stat can begin at is 1
from levelup, you get 99 by level 100, for a score total of 109. You can get 41 others through quests in the game.
Ideally, if you have a score of 150, you have completed everything in the game.

Total quality points should be 9 + LV,
i.e., the player has 1 in all ten qualities at level 1, and gains 3 points total with each level up
upon leveling up the player allocates the 3 new points to the categories of their choice, in any amount they would like

BASE STATS: also called qualities, a players base stats determine all other stats, they can increase with level, and can be temporarily increased or decreased by magical effects. Each base stat affects a set of derived stats
STR - ATCK, BRDN, ATHL
SPD - ATSP, MVMT
SKL - ACCU, CRIT, ATHL, SLTH, TNKR
STM - MXHP, MXMP, RSTN, MVMT, ATHL, ENDR
CON - ATSP, DFNS, MXHP, CAST, CSSP, BRDN, MVMT, ENDR

CHA - PRSD, DCPT
INT - CAST, SPLS, RITL, SLTH, TNKR, INVS, KNLW, DCPT
WIS - MXMP, CAST, CSSP, INVS, PRSD
FTH - CAST, RSNC, LOOT, RITL
LCK - ACCU, EVSN, CRIT, LOOT, KNWL


ITEM WEIGHT REFERENCES:
1 wt = 1/4 lb ==> 1 lb = 4 wt
iron key:     1 (1/4 lb)
glass shard:  1 (1/4 lb)
glass bottle: 2 (1/2 lb)
potion:       4 (1 lb)
shortsword:   8 (2 lbs)
longsword:    20 (5 lbs)
giantsword:   40 (10 lbs)
person:       600 (150 lbs)


ITEM DURABILITY REFERENCES:
(assuming no magical reinforcement)
breadroll:    2
glass bottle: 3
iron key:     5
golden key:   6
wooden sign:  8
wooden table: 9
wooden chest: 10
bronze bell:  12
stone statue: 14
soft sword:   15
hard sword:   18


WEAPON STATS:

weight
affects ATSP, MVMT
ranging 1 - 20

might
affects ATCK
ranging 1 - 20

sleight
affects ACCU
ranging 1 - 20

sharpness
affects CRIT
ranging 1 - 20

range
affects HIT%
ranging 1 - 20

reach
affects attack distance
ranging whatever



ARMOR STATS:

weight
affects CAST, CSSP, MVMT
ranging 1 - 20

protection
affects DFNS
ranging whatever

SHIELD STATS:

weight
affects ATSP
ranging 1 - 20

protection
affects DFNS
ranging whatever



DERIVED STATS:
24 stats, also called abilites. These stats can be affected by base stats, other derived stats, and the player's equipment. These stats affect the actions taken by the player, including attacks, casting spells, and social interaction. Each derived stat has a formula it is determined by.

ACCU - accuracy
50 + 2*SKL + LCK + weapon.sleight
chance to hit against enemy evasion
chance to catch a projectile

ATCK - attack
STR d weapon.might
the amount of max possible damage to the opponent before their damage reduction

ATSP - attack speed
SPD - min0(weapon.weight - CON) - min0(shield.weight - CON)
number of attacks against enemy attack speed
combat order?

EVSN - evasion
2*ATSP + LCK
chance to not avoid hit (against enemy ACCU)
ability to escape restraint

CRIT - critical hit
SKL + LCK + weapon.sharpness
chance of a double-damage hit
ability to get a bullseye

DFNS - defense
CON + armor.protection + shield.protection
physical damage negation

MXHP - max hit point
LV*CON + STM
capacity of total health

MXMP - max magic points
LV*WIS + STM
capacity of total magic

CAST - casting bonus
WIS + FTH + INT - min0(armor.weight - CON)
bonus applied to various magical effects

CSSP - casting speed
WIS - min0(inventory.weight - BRDN) - min0(armor.weight - CON)
speed to cast a spell

SPLS - number of spells
2*INT
the maximum number of spells known

RSTN - resistance
2*FTH + STM
magical damage negation

BRDN - burden
CON*STR + 20
maximum inventory carrying capacity without being hindered
2*BRDN is hard maximum inventory carrying capacity

MVMT - movement
SPD + STM + 10 - min0(inventory.weight - BRDN) - min0(armor.weight - CON) OR mount MVMT
movement distance
turn order

LOOT - item drop rate
2*LCK + FTH
the rate and tier at which items and gold are dropped by enemies

RITL - ritual
2*FTH + LCK
ability to cast magical rituals and healing spells

ATHL - athletics
STR + SKL + STM
ability to achieve physical feats
ability to climb walls
ability to restrain an enemy (against their EVSN)
ability to ride an unwilling enemy (against their ATHL)

ENDR - endurance
2*STM + CON
ability to endure things (poison, holding breath, regeneration, etc.)

SLTH - stealth
2*SKL + INT - min0(inventory.weight - BRDN)
ability to hide
ability to steal without being noticed

TNKR - tinker
2*INT + SKL
ability to craft items
quality of cooked items
quality of repaired items

INVS - investigation
2*WIS + INT
ability to percieve lies
ability to perceive hidden creatures and things

KNWL - knowledge
2*INT + LCK
chance to know things (unlocks some intelligent dialogue)
unlocks ability to craft certain items and learn certain spells

PRSD - persuasion
2*CHA + WIS
ability to persuade (unlocks some persuasive dialogue)

DCPT - deception
2*CHA + INT
ability to deceive (unlocks some deceptive dialogue)



SWITCHES, LEVERS, BUTTONS:

A switch is a superclass which contains levers and buttons
Switches can be interacted with (via "use","pull","switch","press",etc.)
When a switch is "triggered", it calls a specific effect which affects something about the world. In data, switches are stored with a string which refers to a function stored in the effects dict (at the bottom of Objects.py)
This function is called when a switch is "triggered"

Levers are switches that have 2 states; on or off. They change something when switched "on", and have the reverse effect when switched "off"

Buttons are switches that simply do something when they are triggered. There can be permanent buttons, which can only be triggered once, or recurring buttons which can be triggered multiple times.

Traps are switches that are triggered when the player performs an action other than "pull","switch", or "press". In other words, a switch which is triggered unintentionally by the player. Typically, a trap can only be triggered once, i.e. it has an attribute which begins as "off" and can only be changed to "on"


WHAT CAN SWITCHES DO? (EXAMPLES)

They can change the gamemode
They can make an item or creature appear in the room
Can alter something about an item, creature, or fixture in the room
They can reveal a door to another room
They can alter a players stats or status
They can alter something in a different room in the world



A GENERIC ACTION FUNCTION:

if prepositions are invalid, return false
if dobj or iobj values are required but not provided, ask for them
search for required iobj and dobj objects in room or on player:
	if they do not exist, return false
if required iobj and dobj do not have the necessary attributes, return
if the item object is affected in some way, call the relevant item methods
if the player object is affected in some way, call relevant player methods
return True


TYPES OF ACTION FUNCTIONS:

-no-prep function: functions which cannot take a preposition value:
-single-prep functions: functions which take a single prepositon, usually "with"
-multi-prep functions: functions which take a number of possible prep values

-inventory search function: functions which search the player inv for an item
-room item search function: functions which search room contents for an item
-room creature search function: search room occupants for a creature
-room search functions: search room for an item or creature
-item search function: search room and player inv for an item
-object search function: search room and player inv for creature or item


IDEAS FOR CREATURES/NPCS:

generally, three categories of creatures,
person, monster, animal
"villain" - subclass; big bad version of person
"boss" - subclass; big bad version of a monster
"beast" - subclass; big bad version of an animal

all creatures have two stats associated with behavior toward the player:

fondness: -100 to 100, represents how much they like the player, a creature with high fondness for the player is less likely to act aggressively toward the player, and more likely to be persuaded or deceived by the player

fear: -100 to 100, represents how much they fear the player, a creature with high fear of the player is less likely to act aggressively toward the player, and less likely to be deceived by the player, but more likely to be persuaded

people have dialogue options for the player and can be communicated with, persuaded, or deceived.

monsters and animals cannot communicate with the player. Animals typically act more passively than monsters and have a limited set of actions they can take. Monsters can use items and weapons.

each person has an initial value for their fondness and fear of new strangers (meaning the player), but upon meeting the player each time, their values deviate from that initial value with a firstImpression() function, which takes in several factors, including the player's amount gear, their type of gear, and their reputation points and sets their fondness and fear values. fear and fondness change with very subsequent meeting with the player to a lesser degree based on the same factors.

fondness and fear are changed by specific dialogue options pursued by the player, and specific actions taken by the player taken toward the creature. additionally, dialogue options the player has with a given person are dependent upon how fond or fearful the person is.

These values can also change, for monsters and animals as well, based on certain actions like giving gifts, buying and selling merchandise, attacking, healing, or casting a spell

//note: creatures should contain a value which indicates how it will be addressed e.g. "The goblin", "Goblin", "a goblin", "goblins"


MAKING AN ATTACK:

turn order is determined by ATSP:
    order is highest to lowest attack speed,
    ties are settled by the highest SPD
    ties of SPD are settled by 'attacker goes first'
number of attacks is determined:
    n = floor(ATSP / target.ATSP) //maybe
for each attack:
    chance to hit is determined:
        if weapon.ranged
            HIT = min1(max99(ACCU - target.EVSN)) - min0(dist(player, target) - weapon.range)
        else
            HIT = min1(max99(ACCU - target.EVSN))
		percentage roll to HIT
    chance to crit is rolled
    attack is rolled:
		attack = STR d weapon.might
		if critical
			attack *= 3
    damage is calculated:
		damage = min0(attack - target.DFNS)
    damage is dealt:
        enemy.hp -= damage
		#called in the enemy object, dmgtype passed as well

EQUIPPING ITEMS/WEAPONS:

ASSIGNING WEAPONS AND SHIELDS

CASTING A SPELL:

really just depends...



DAMAGE TYPES:

p: piercing	[phys] - weapons that can stab
s: slashing	[phys] - weapons that can slice
b: bludgeoning	[phys] - weapons that can crush

f: fire	[elem] - weapons that can burn [can cause burning condition]
c: cold	[elem] - weapons that can freeze [can cause frozen condition]
l: lightning [elem] - weapons that can shock [can cause paralyzed condition]
t: thunder [elem] - weapons that can boom [can cause deafened condition]
a: acid [elem] - weapons that can corrode
x: poison [elem] - weapons that can poison (duh)

n: necrotic [mag] - weapons that drain lifeforce
r: radiant [mag] - weapons that imbue holiness
v: force	[mag] - weapons that evoke magical force
i: psychic [mag] - weapons that harm the mind

e: essential [dev] - weapons that transcend the universe



STATUS EFFECTS:

status conditions exist in the creatures status list as list pairs
of condition name and duration.
negative durations have special meanings:
-1 means the condition is permanent (should be rarely used)
-2 means the condition is permanent until removed by any general source
-3 means the condition is inflicted by being in the current room
-4 or lower means the condition is permanent until removed by some specific source


rooms have status effects too. And rooms can harbor condition which afflict creatures in the room with other status conditions. When this happens, the room condition's name will contain the information about the condition to inflict upon the creatures. For instance, if a room is filled with poisonous gas for 30 time units and will poison all creatures that enter until they leave (or until the rooms condition wears off). the rooms condition pair would be of the form:

["afflict poisoned -2", 30]

if the room is simply on fire for 10 more time units, and will ignite any creatures in the room for 15 units, even leaving the room will not save them after being set ablaze. In this case, the room's condition pair would be of the form:

["afflict on fire 15", 10]




